Beomjoo Jayden Kim - Studying_Python

Disclaimer: 가독성을 높이려기보다는 개인화에 집중하였으므로 타인이 내용을 이해하기에는 최적이 아닐 수 있다.


아래는 공부가 진행되는 경과와, 중요한 대목들을 요약한 내용.
syntax와 몇 개의 function을 제외하면 두 언어가 대동소이하므로, C++과 python이 서로 다른 부분만을 확인해가면서 공부하는 것이 가장 효율적이라는 결론을 내렸다.
'혼공파' 목차 상 8개의 챕터로 구성되어 있는데, 첫 6개의 챕터는 하루에 하나씩 다루고 끝 두 개의 챕터를 사나흘에 걸쳐 다뤄 결과적으로 2주 안에 이 책을 독파하는 것을 목표로 한다.




21.03.22.   [p2 ~ p105]
Chapter 01, 02. STARTING PYTHON & DATA

● 주석:         C++        Python
한 줄 주석       //         #           
여러 줄 주석     /* */      """/'''
★ 전체 주석화: 그냥 해당 부분 전체 드래그 후 crtl + /


● 자료형:
int bool string char 다 있지만 사용법이 약간 다름.
int animal = 4;     는 animal = 4   로 표현. 자료형 명시 X ; 안 붙이고.
bool is_adult() {if(age>=3) true}   는 걍 is_adult = age >= 3    으로 표현.

print ("우리 집 동물 종류는 " + animal + "가지입니다.")
에서 위 처럼 표현하면 안 됨. animal이 string이 아니므로 형변환 str(animal) 꼭 해줘야.
print ("우리 집 동물 종류는 " + str(animal) + "가지입니다.")
그리고, + 대신 , 사용 가능. 이때는 str function 없이 즉,
print ("우리 집 동물 종류는 " , animal , "가지입니다.")
도 똑같이 유효한 표현.

cast는, C++의 (int) s 와 달리 걍 int(s) 식으로 해준다.
C++보다는 훨씬 유연하게 형변환이 가능하다. 그러나,
int("안녕하세요") 나 int("52.3")과 같은 경우는 ValueError를 반환한다. 한 번만에 변환이 가능해야만 cast가 성립한다.

파이썬의 유연성: 파이썬은 기본적으로 변수를 사용할 때 변수의 자료형을 미리 선언 안 한다. 그래서 아래와 같은 요술?이 가능하다.
a = 1, a = "말도 안 돼!", a = 1.5
유연하기 때문에 좋다고 할 수도 있겠지만, 동시에 TypeError를 유발할 가능성도 커질 것으로 보인다.

● 연산자와 수식:
제곱은 x**y. pow도 똑같이 있다. abs,  max, min, round 연산자도 있다. library 없이 걍 쓰면 됨.
not 연산자도 있다. 그냥 1 != 3 은 true인데 not(1 != 3)은 false임.
and 연산자도 있다. C++의 && 와 같다. or 연산자도 있다. C++의 || 와 같다.
몫은 5//3 이렇게. C++에서는 걍 /해주면 되는데. 여기선 5/3해주면 1.6666의 float값이 나온다. 신-기

● library 사용:
from math import *   해석하면 #include <math>. 물론 c++에서는 cmath 사용.
floor, ceil, sqrt 는 c++과 동일하게 사용.
from random import *   난수. 
print(random())   0.0 ~ 1.0 사이의 임의의 값 출력.

● -1. 문자열:
기본적으로 ''와 "" 사이의 차이가 없다 그리고 아까 주석이라 했던 """도 string으로 인정!!

● -2. 슬라이싱:
sentence = "blah blah"
print(sentence[3:5])  인덱스 기준 3 이상 5 미만 글자 다 가져옴.
print(sentence[-4:])  인덱스 기준 뒤에서 4번째부터 끝까지.

● -3. 문자열 처리 함수:
print(sentence.lower())     tolower와 비슷.
print(sentence.upper())     toupper와 비슷.        // upper/lower과 tolower/toupper 함수는 결과물은 비슷하지만, upper와 lower는 비파괴적 함수라는 점이 다르다.
print(sentence[0].isupper)
print(len(sentence))        length.sentence와 같음.
print(sentence.replace("abc", "def"))   C++의  replace 함수는 노답.
index = sentence.index("n")   sentence에서 n의 인덱스 찾기. 
    근데 n 첫 번째 거 말고 뒤에 거 원하면 sentence.index("n", index +1)
뒤의 index + 1 은 시작점.
find도 index와 똑같은 녀석. 근데 find는 찾는 게 없으면 -1, index는 에러 뜸.
sentence.count("n")은 n의 개수 반환.

● 사용자 입력: input()
input 함수로 사용자 입력받기
다른 언어에서도 마찬가지지만, input함수는 항상 출력과 입력과 block 기능을 모두 가지고 있음으로 인한 헛갈림을 야기할 수 있다.
>>> input("인사말을 입력하세요!")
단순히 이렇게 쓰기만 하면, 인사말을 입력하세요! 를 출력하고 컴파일을 순간적으로 중단(block)하여 input을 받을 준비를 한다.
중요한 것은, input을 통해 받은 데이터는 123이건 "kim"이건 무조건 string 형식인 것이다.

● -4. 문자열 포맷
print("a" + "b")        ab 출력.   모두 str로 형 변환 해줘야 함.
print ("a", "b")        a b 출력.  굳이 형변환해주지 않아도 된다는 것.
print("나는 %d살입니다." %20)             %d는 int 꼴
print("나는 %s을 좋아해요." %"파이썬")     %s는 string 꼴
print("Apple은 %c로 시작해요." % "A")     %c는 char 꼴
# %s는 string뿐 아니라 만능, 그 어떤 걸 넣어도 됨.
print("나는 %s색과 %s색을 좋아해요" %("파란", "빨간"))

print("나는 {}살입니다." .format(20))
print("나는 {}색과 {}색을 좋아해요" .format("파란", "빨간"))
print("나는 {1}색과 {0}색을 좋아해요" .format("파란", "빨간"))    #중괄호 안의 숫자는 뒤의 format 상의 순서의 element.
print("나는{age}살이며, {color}색을 좋아해요" .format(age = 20, color="빨간"))   #중괄호 속의 변수를 부름.
format의 경우 {}의 개수가 함수의 매개변수의 개수보다 많으면 IndexError를 반환하지만 그 반대의 경우는 문제가 없다.

그리고 포맷을 다루는 데에 있어서, 디테일에 특별히 신경써줘야 하는 부분이 있다.
p95 - p99에 해당하는 부분인데, 이 부분은 외우기보다는 필요 시에 꺼내쓰도록 하자.
추가로,
strip()     문자열 양옆의 공백 제거
isseries()  isalnum(), isalpha(), isidentifier(), isdecimal(), isdigit(), isspace() 등의 판별함수도 있다.

문자열을 찾을 때는 find()와 rfind() 함수가 있다. find()는 왼쪽부터, rfind()는 오른쪽부터 찾아서 처음 등장하는 위치를 찾는다.
문자열 내부에 어떤 문자열이 있는지 확인하려면 in연산자를 사용한다. 출력은 True 또는 False로. ex) "안녕" in "안녕하세요" returns: True
문자열을 자를 때: a = "10 20 30 40 50".split(" ") print(a)를 해주면 공백을 기준으로 주어진 녀석을 잘라, ['10', '20', '30', '40', '50'] 이러한 list를 반환한다.

\n은 줄바꿈. \" \"은 그대로 출력하기. \\는 문장 내에서 \를 출력. \r은 커서를 앞으로 이동. \b는 백스페이스. \t는 탭.














21.03.23.   [p106 ~ p]
Chapter 03. CONDITIONAL STATEMENTS

● -1. if statement
다른 것들은 C++과 대동소이하지만, 범위를 적용할 때 10 < x && x < 30 이렇게 해줬던 것과는 달리 10 < x < 30으로 바로 작성해줘도 된다.
Logical Operator: NOT, OR, AND 는 각각 !, ||, &&에 대응된다. 그냥 기호를 사용 자체를 하지 않는 것 같다.

if statement도 C++과 다르다.
if bool statement:
OOOOstatement if true
OOOOstatement if true   // tab을 사용하려 했는데 이건 8 spaces와 같아서 사용 불가. 보통 저 OOOO의 자리에는 4 spaces가 들어가야 한다.
                        // IDLE이나 VS 같은 개발 전용 에디터에서는 TAB 키를 자동으로 4개짜리로 만들어 뒀다. soft tab 기능. 
            ...
의 꼴을 가진다.

line by line의 interactive shell에서 if는 여러 줄을 필요로 하므로 엔터키를 누르면 자동으로 다음 줄의 프롬프트 위치에 ...가 나타난다. 그 위치로부터 1 tab 후에 실행 문장을 입력하면 됨.

날짜/시간 활용하기
import datetime         // 나중에 배우겠지만, import 모듈 하는 방법과 from 모듈 import 필요한 함수 하는 방법이 있다. just so you know...
now = datetime.datetime.now() 를 해주고 나서 필요에 따라
now.year now.month now.day now.hour now.minute now.second 이렇게 now 속의 변수들을 사용할 수 있다.
쉽게 출력하려면 기존의 format 함수를 활용하여,
print("{}년 {}월 {}일 {}시 {}분").format(now.year, now.month, now.day, now.hour, now.minute) 이렇게 사용 가능.

● -2. if else statement, elif statement
if-else와 elif 구문은 위의 if 템플릿을 기반으로 활용해주면 된다. easy peasy
if else 를 사용하다가 어느 시점에 만약 아무 실행문도 없는 녀석이 등장하면 C++에서는 그냥 ;로 뒀었는데 여기서는 pass를 사용해서 가독성을 높인다. 아무것도 없으면 IndentationError 뜬다.


Chapter 04. DATA STRUCTRES & LOOPS

● -1. Data Structures: LIST(= 업그레이드 버전 배열)
subway = [123, 234, 345]
단순히 print(subway) 를 컴파일하면 [123, 234, 345] 이 출력됨.
index       print(subway.index(234)) 를 하면 해당 인덱스 1이 출력됨                 <---- 상당히 좋은 기능이다. C++에서는 이 기능을 쓰기 위해서는 Hash를 써야하는 귀찮음이 있다.
append      print(subway.append(456)) 를 하면 그냥 vector.push_back(456)과 같다.
pop         subway.pop()은 마지막 녀석 제거, (인덱스)하면 해당 녀석 제거.
del         del. 리스트명 [인덱스]
remove      리스트.remove(값)
count       subway.count(123)은 123이 몇 번 나오는지.
sort        subway.sort()
reverse     subway.reverse()
clear       subway.clear()  모두 제거!
extend      subway.extend(plus_statement) 하면 + 됨.
    ☆ 레전드급으로 신나는 함수는 insert 함수다. 분명 배열은 중간에 삽입이 안 되는데
insert      subway.insert(1, 111) 해주면 기존의 123과 234 사이에 111을 넣어준다. 황-홀.      <--- 위치, 성분 순서임을 간과하지 말자.
    ☆ 그리고 또 하나의 레전드. 여러 개의 자료형을 하나의 리스트에 함께 저장 가능하다.
users = range(1,21) 이렇게 range를 해주면 크기 설정 가능. 근데 이건 type이 range. list로 바꿔줘야 함.   <---- 따로 loop을 돌릴 필요 없이 type만 변경하면 list로 쓸 수 있다.
users = list(users) 해주면 됨~

in/ not in 연산자: 값 in 리스트 꼴 혹은 값 not in 리스트 꼴. 리스트 내부에 해당 값이 있는지 여부를 판단하는 연산.

● -2. TUPLE
리스트의 하위호환 버전. 한 번 만들어두면 값을 추가, 변경, 삭제하는 것은 불가능하다. 
그렇지만 두 개의 장점이 있다.   1. 속도가 리스트보다 빠르다.     2. 한 번에 자료형이 서로 다른 여러 개의 변수 정의 가능.
                                menu = ("돈까스", "치즈까스")   (나이, 이름, 취미) = (24, 김범주, 축구)

● -3. SET
중복을 허용하지 않고, 순서는 따로 없다.                 <---- C++의 set과는 다른 것이, 중복을 허용하지 않는 것까지는 같으나 정렬이 안 된다는 것이 중요한 포인트이다.
my_set = {1,2,3,3,3} 은 자동적으로 {1,2,3}으로 바뀐다.
A & B 는 곧 A.intersection(B)
A | B 는 곧 A.union(B)
A - B 는 곧 A.difference(B)
그리고 add(), remove() 등의 STL 사용 가능.

● -4. OVERALL
위에서 본 것처럼,
튜플은 ()로, 리스트는 []로, 세트는 {}로 표현을 하는데, 이미 다른 자료구조로 정의를 한 후에도 다른 자료구조로 바꿀 수 있다.
menu = {a, b, c}         list(menu)      하면 세트에서 리스트로 바뀜.

● 딕셔너리와 반복문
리스트가 '인덱스를 기반으로 값을 저장하는 것'이라면 딕셔너리는 '키를 기반으로 값을 저장하는 것'이라고 할 수 있다.
{"키A" : 10, "키B" : 20, ...} 이런 식으로. 키는 문자열, 숫자, 불리언 모두 가능하지만 보통 문자열을 사용한다. 
딕셔너리를 생성할 때는 {}를 사용하지만, 만들어진 딕셔너리에서 값을 불러올 때는 []을 사용한다. 마치 리스트에서 인덱스를 사용하는 것과 유사하게. 헛갈릴 수 있으니 주의하자.
    ☆ 그리고 계속 반복적으로 나오지만, 리스트를 비롯한 자료구조들은 서로 다른데도 불구하고 결과론적으로 혼용되어 사용될 수 있다. 물론 2D로 사용도 할 수 있다.
이미 만들어진 딕셔너리에 새로운 키를 넣고 싶으면 dictionary["price"] = 5000 이런 식으로 넣으면 된다.
제거 역시 del 키워드로 del dictionary["ingredient"] 이렇게 해주면 된다.

딕셔너리 내부에 키가 있는지 확신하는 방법은,
1. if - in 키워드를 써서 if key in dictionary: print 해주는 방법이 있고,
2. get() 함수를 써서 None을 따주는 방법이 있다.

● for 반복문
for i in range(100): 
    print("출력")                 <-- 또 다른 C++과의 큰 차이: 공백을 주의해야 함. C++은 프로그래밍 자체의 순서가 중요했지, 사이에 여백이 있는지 여부는 중요하지 않다.

● range 자료형
1. range(A)     0부터 A-1까지의 정수로 범위를 만듦, 공차는 1
2. range(A,B)   A부터 B-1까지의 정수로 범위를 만듦, 공차는 1
3. range(A,B,C) A부터 B-1까지의 정수로 범위를 만듦, 공차는 C
-> 범위의 우측 끝값은 포함이 안 된다는 것을 명심.

for loop에도 사용이 된다.
for i in range(blah):
    print(str(i) + " = 반복 변수") 처럼!
역순은 위의 3번 내용을 활용하던가, reversed(range(5)) 이런 식으로 사용해줘도 된다.

● while 반복문
while bool_expression:
    do_expression

그냥 반복문과 조건문은 템플릿만 외우면 그 꼴에 맞춰주면 됨.

