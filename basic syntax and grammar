Beomjoo Jayden Kim - Studying_Python

Disclaimer: 가독성을 높이려기보다는 개인화에 집중하였으므로 타인이 내용을 이해하기에는 최적이 아닐 수 있다.

아래는 공부가 진행되는 경과와, 중요한 대목들을 요약한 내용.
syntax와 몇 개의 function을 제외하면 두 언어가 대동소이하므로, C++과 python이 서로 다른 부분만을 확인해가면서 공부하는 것이 가장 효율적이라는 결론을 내렸다.
'혼공파' 목차 상 8개의 챕터로 구성되어 있는데, 첫 6개의 챕터는 하루에 하나씩 다루고 끝 두 개의 챕터를 사나흘에 걸쳐 다뤄 결과적으로 2주 안에 이 책을 독파하는 것을 목표로 한다.


21.03.22.   [p2 ~ p105]
Chapter 01, 02. STARTING PYTHON & DATA

● 주석:         C++        Python
한 줄 주석       //         #           
여러 줄 주석     /* */      """/'''
★ 전체 주석화: 그냥 해당 부분 전체 드래그 후 crtl + /

● 자료형:
int bool string char 다 있지만 사용법이 약간 다름.
int animal = 4;     는 animal = 4   로 표현. 자료형 명시 X ; 안 붙이고.
bool is_adult() {if(age>=3) true}   는 걍 is_adult = age >= 3    으로 표현.

print ("우리 집 동물 종류는 " + animal + "가지입니다.")
에서 위 처럼 표현하면 안 됨. animal이 string이 아니므로 형변환 str(animal) 꼭 해줘야.
print ("우리 집 동물 종류는 " + str(animal) + "가지입니다.")
그리고, + 대신 , 사용 가능. 이때는 str function 없이 즉,
print ("우리 집 동물 종류는 " , animal , "가지입니다.")
도 똑같이 유효한 표현.

cast는, C++의 (int) s 와 달리 걍 int(s) 식으로 해준다.
C++보다는 훨씬 유연하게 형변환이 가능하다. 그러나,
int("안녕하세요") 나 int("52.3")과 같은 경우는 ValueError를 반환한다. 한 번만에 변환이 가능해야만 cast가 성립한다.

파이썬의 유연성: 파이썬은 기본적으로 변수를 사용할 때 변수의 자료형을 미리 선언 안 한다. 그래서 아래와 같은 요술?이 가능하다.
a = 1, a = "말도 안 돼!", a = 1.5
유연하기 때문에 좋다고 할 수도 있겠지만, 동시에 TypeError를 유발할 가능성도 커질 것으로 보인다.

● 연산자와 수식:
제곱은 x**y. pow도 똑같이 있다. abs,  max, min, round 연산자도 있다. library 없이 걍 쓰면 됨.
not 연산자도 있다. 그냥 1 != 3 은 true인데 not(1 != 3)은 false임.
and 연산자도 있다. C++의 && 와 같다. or 연산자도 있다. C++의 || 와 같다.
몫은 5//3 이렇게. C++에서는 걍 /해주면 되는데. 여기선 5/3해주면 1.6666의 float값이 나온다. 신-기

● library 사용:
from math import *   해석하면 #include <math>. 물론 c++에서는 cmath 사용.
floor, ceil, sqrt 는 c++과 동일하게 사용.
from random import *   난수. 
print(random())   0.0 ~ 1.0 사이의 임의의 값 출력.

● -1. 문자열:
기본적으로 ''와 "" 사이의 차이가 없다 그리고 아까 주석이라 했던 """도 string으로 인정!!

● -2. 슬라이싱:
sentence = "blah blah"
print(sentence[3:5])  인덱스 기준 3 이상 5 미만 글자 다 가져옴.
print(sentence[-4:])  인덱스 기준 뒤에서 4번째부터 끝까지.

● -3. 문자열 처리 함수:
print(sentence.lower())     tolower와 비슷.
print(sentence.upper())     toupper와 비슷.        // upper/lower과 tolower/toupper 함수는 결과물은 비슷하지만, upper와 lower는 비파괴적 함수라는 점이 다르다.
print(sentence[0].isupper)
print(len(sentence))        length.sentence와 같음.
print(sentence.replace("abc", "def"))   C++의  replace 함수는 노답.
index = sentence.index("n")   sentence에서 n의 인덱스 찾기. 
    근데 n 첫 번째 거 말고 뒤에 거 원하면 sentence.index("n", index +1)
뒤의 index + 1 은 시작점.
find도 index와 똑같은 녀석. 근데 find는 찾는 게 없으면 -1, index는 에러 뜸.
sentence.count("n")은 n의 개수 반환.

● 사용자 입력: input()
input 함수로 사용자 입력받기
다른 언어에서도 마찬가지지만, input함수는 항상 출력과 입력과 block 기능을 모두 가지고 있음으로 인한 헛갈림을 야기할 수 있다.
>>> input("인사말을 입력하세요!")
단순히 이렇게 쓰기만 하면, 인사말을 입력하세요! 를 출력하고 컴파일을 순간적으로 중단(block)하여 input을 받을 준비를 한다.
중요한 것은, input을 통해 받은 데이터는 123이건 "kim"이건 무조건 string 형식인 것이다.

● -4. 문자열 포맷
print("a" + "b")        ab 출력.   모두 str로 형 변환 해줘야 함.
print ("a", "b")        a b 출력.  굳이 형변환해주지 않아도 된다는 것.
print("나는 %d살입니다." %20)             %d는 int 꼴
print("나는 %s을 좋아해요." %"파이썬")     %s는 string 꼴
print("Apple은 %c로 시작해요." % "A")     %c는 char 꼴
# %s는 string뿐 아니라 만능, 그 어떤 걸 넣어도 됨.
print("나는 %s색과 %s색을 좋아해요" %("파란", "빨간"))

print("나는 {}살입니다." .format(20))
print("나는 {}색과 {}색을 좋아해요" .format("파란", "빨간"))
print("나는 {1}색과 {0}색을 좋아해요" .format("파란", "빨간"))    #중괄호 안의 숫자는 뒤의 format 상의 순서의 element.
print("나는{age}살이며, {color}색을 좋아해요" .format(age = 20, color="빨간"))   #중괄호 속의 변수를 부름.
format의 경우 {}의 개수가 함수의 매개변수의 개수보다 많으면 IndexError를 반환하지만 그 반대의 경우는 문제가 없다.

그리고 포맷을 다루는 데에 있어서, 디테일에 특별히 신경써줘야 하는 부분이 있다.
p95 - p99에 해당하는 부분인데, 이 부분은 외우기보다는 필요 시에 꺼내쓰도록 하자.
추가로,
strip()     문자열 양옆의 공백 제거
isseries()  isalnum(), isalpha(), isidentifier(), isdecimal(), isdigit(), isspace() 등의 판별함수도 있다.

문자열을 찾을 때는 find()와 rfind() 함수가 있다. find()는 왼쪽부터, rfind()는 오른쪽부터 찾아서 처음 등장하는 위치를 찾는다.
문자열 내부에 어떤 문자열이 있는지 확인하려면 in연산자를 사용한다. 출력은 True 또는 False로. ex) "안녕" in "안녕하세요" returns: True
문자열을 자를 때: a = "10 20 30 40 50".split(" ") print(a)를 해주면 공백을 기준으로 주어진 녀석을 잘라, ['10', '20', '30', '40', '50'] 이러한 list를 반환한다.

\n은 줄바꿈. \" \"은 그대로 출력하기. \\는 문장 내에서 \를 출력. \r은 커서를 앞으로 이동. \b는 백스페이스. \t는 탭.


21.03.23.   [p106 ~ p]-----------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 03. CONDITIONAL STATEMENTS

● -1. if statement
다른 것들은 C++과 대동소이하지만, 범위를 적용할 때 10 < x && x < 30 이렇게 해줬던 것과는 달리 10 < x < 30으로 바로 작성해줘도 된다.
Logical Operator: NOT, OR, AND 는 각각 !, ||, &&에 대응된다. 그냥 기호를 사용 자체를 하지 않는 것 같다.

if statement도 C++과 다르다.
if bool statement:
OOOOstatement if true
OOOOstatement if true   // tab을 사용하려 했는데 이건 8 spaces와 같아서 사용 불가. 보통 저 OOOO의 자리에는 4 spaces가 들어가야 한다.
                        // IDLE이나 VS 같은 개발 전용 에디터에서는 TAB 키를 자동으로 4개짜리로 만들어 뒀다. soft tab 기능. 
            ...
의 꼴을 가진다.

line by line의 interactive shell에서 if는 여러 줄을 필요로 하므로 엔터키를 누르면 자동으로 다음 줄의 프롬프트 위치에 ...가 나타난다. 그 위치로부터 1 tab 후에 실행 문장을 입력하면 됨.

날짜/시간 활용하기
import datetime         // 나중에 배우겠지만, import 모듈 하는 방법과 from 모듈 import 필요한 함수 하는 방법이 있다. just so you know...
now = datetime.datetime.now() 를 해주고 나서 필요에 따라
now.year now.month now.day now.hour now.minute now.second 이렇게 now 속의 변수들을 사용할 수 있다.
쉽게 출력하려면 기존의 format 함수를 활용하여,
print("{}년 {}월 {}일 {}시 {}분").format(now.year, now.month, now.day, now.hour, now.minute) 이렇게 사용 가능.

● -2. if else statement, elif statement
if-else와 elif 구문은 위의 if 템플릿을 기반으로 활용해주면 된다. easy peasy
if else 를 사용하다가 어느 시점에 만약 아무 실행문도 없는 녀석이 등장하면 C++에서는 그냥 ;로 뒀었는데 여기서는 pass를 사용해서 가독성을 높인다. 아무것도 없으면 IndentationError 뜬다.


Chapter 04. DATA STRUCTRES & LOOPS

● -1. Data Structures: LIST(= 업그레이드 버전 배열)
subway = [123, 234, 345]
단순히 print(subway) 를 컴파일하면 [123, 234, 345] 이 출력됨.
index       print(subway.index(234)) 를 하면 해당 인덱스 1이 출력됨                 <---- 상당히 좋은 기능이다. C++에서는 이 기능을 쓰기 위해서는 Hash를 써야하는 귀찮음이 있다.
append      print(subway.append(456)) 를 하면 그냥 vector.push_back(456)과 같다.
pop         subway.pop()은 마지막 녀석 제거, (인덱스)하면 해당 녀석 제거.
del         del. 리스트명 [인덱스]
remove      리스트.remove(값)
count       subway.count(123)은 123이 몇 번 나오는지.
sort        subway.sort()
reverse     subway.reverse()
clear       subway.clear()  모두 제거!
extend      subway.extend(plus_statement) 하면 + 됨.
    ☆ 레전드급으로 신나는 함수는 insert 함수다. 분명 배열은 중간에 삽입이 안 되는데
insert      subway.insert(1, 111) 해주면 기존의 123과 234 사이에 111을 넣어준다. 황-홀.      <--- 위치, 성분 순서임을 간과하지 말자.
    ☆ 그리고 또 하나의 레전드. 여러 개의 자료형을 하나의 리스트에 함께 저장 가능하다.
users = range(1,21) 이렇게 range를 해주면 크기 설정 가능. 근데 이건 type이 range. list로 바꿔줘야 함.   <---- 따로 loop을 돌릴 필요 없이 type만 변경하면 list로 쓸 수 있다.
users = list(users) 해주면 됨~

in/ not in 연산자: 값 in 리스트 꼴 혹은 값 not in 리스트 꼴. 리스트 내부에 해당 값이 있는지 여부를 판단하는 연산.

● -2. TUPLE
리스트의 하위호환 버전. 한 번 만들어두면 값을 추가, 변경, 삭제하는 것은 불가능하다. 
그렇지만 두 개의 장점이 있다.   1. 속도가 리스트보다 빠르다.     2. 한 번에 자료형이 서로 다른 여러 개의 변수 정의 가능.
                                menu = ("돈까스", "치즈까스")   (나이, 이름, 취미) = (24, 김범주, 축구)

● -3. SET
중복을 허용하지 않고, 순서는 따로 없다.                 <---- C++의 set과는 다른 것이, 중복을 허용하지 않는 것까지는 같으나 정렬이 안 된다는 것이 중요한 포인트이다.
my_set = {1,2,3,3,3} 은 자동적으로 {1,2,3}으로 바뀐다.
A & B 는 곧 A.intersection(B)
A | B 는 곧 A.union(B)
A - B 는 곧 A.difference(B)
그리고 add(), remove() 등의 STL 사용 가능.

● -4. OVERALL
위에서 본 것처럼,
튜플은 ()로, 리스트는 []로, 세트는 {}로 표현을 하는데, 이미 다른 자료구조로 정의를 한 후에도 다른 자료구조로 바꿀 수 있다.
menu = {a, b, c}         list(menu)      하면 세트에서 리스트로 바뀜.

● 딕셔너리와 반복문
리스트가 '인덱스를 기반으로 값을 저장하는 것'이라면 딕셔너리는 '키를 기반으로 값을 저장하는 것'이라고 할 수 있다.
{"키A" : 10, "키B" : 20, ...} 이런 식으로. 키는 문자열, 숫자, 불리언 모두 가능하지만 보통 문자열을 사용한다. 
딕셔너리를 생성할 때는 {}를 사용하지만, 만들어진 딕셔너리에서 값을 불러올 때는 []을 사용한다. 마치 리스트에서 인덱스를 사용하는 것과 유사하게. 헛갈릴 수 있으니 주의하자.
    ☆ 그리고 계속 반복적으로 나오지만, 리스트를 비롯한 자료구조들은 서로 다른데도 불구하고 결과론적으로 혼용되어 사용될 수 있다. 물론 2D로 사용도 할 수 있다.
이미 만들어진 딕셔너리에 새로운 키를 넣고 싶으면 dictionary["price"] = 5000 이런 식으로 넣으면 된다.
제거 역시 del 키워드로 del dictionary["ingredient"] 이렇게 해주면 된다.

딕셔너리 내부에 키가 있는지 확신하는 방법은,
1. if - in 키워드를 써서 if key in dictionary: print 해주는 방법이 있고,
2. get() 함수를 써서 None을 따주는 방법이 있다.

● for 반복문
for i in range(100): 
    print("출력")                 <-- 또 다른 C++과의 큰 차이: 공백을 주의해야 함. C++은 프로그래밍 자체의 순서가 중요했지, 사이에 여백이 있는지 여부는 중요하지 않다.

● range 자료형
1. range(A)     0부터 A-1까지의 정수로 범위를 만듦, 공차는 1
2. range(A,B)   A부터 B-1까지의 정수로 범위를 만듦, 공차는 1
3. range(A,B,C) A부터 B-1까지의 정수로 범위를 만듦, 공차는 C
-> 범위의 우측 끝값은 포함이 안 된다는 것을 명심.

for loop에도 사용이 된다.
for i in range(blah):
    print(str(i) + " = 반복 변수") 처럼!
역순은 위의 3번 내용을 활용하던가, reversed(range(5)) 이런 식으로 사용해줘도 된다.

● while 반복문
while bool_expression:
    do_expression

● do while 반복문
do:
    task() 
while condition

break와 continue 키워드: break 키워드는 반복문을 벗어날 때 사용하면 되고, continue는 현재 반복 loop을 벗어나지는 않고서 이번 턴만 넘기고 싶을 때.

그냥 반복문과 조건문은 템플릿만 외우면 그 꼴에 맞춰주면 됨.

● 문자열, 리스트, 딕셔너리와 관련된 기본 함수

reverse() vs. reversed()
reversed()는 아무것도 뒤집지 않는다. 다만 주어진 녀석을 반대 방향으로 iterate 하는 것 뿐. reversed()와 같은 표현으로는 [::-1]이 있다.
reverse()는 해당 data structure 등을 actually 뒤집는다.
아니면 그냥 reverse는 아예 기존 녀석을 갈아엎는 것이고, reversed는 제네레이터로서 일회성으로 생성되는 것이라고 생각해도 된다.

enumerate 함수도 역시 일회성으로 생성되는 제네레이터인데, 이런 일회용 제네레이터들은 자칫 잘못 썼다가 바로 삭제가 되므로 생성과 동시에 사용해야만 한다.
예를 들면 list(enumerate(example_list)) 이런 식으로. 근데 enumerate 함수는 솔직히 별로 쓸모없을 것으로 예상된다.

● 리스트 내포
array = [i*i for i in range(0, 20, 2)]  이런 식으로 표현도 가능함. 저 순서가 중요하다. i는 0, 2, 4, ... 이렇게 진행되는데 그 각각의 제곱을 array에 넣어야 하니까.
list_name = [expression for iterator in some_range]


0900-1200: 05-01, 02
1300-1500: 05-03
1530-1800: 프로그래머스 자료구조 알고리즘 풀이.


21.03.24.   [p210 ~ p]-----------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 05. FUNCTION

● 함수의 기본
def 함수 이름():
    문장
-> 꼴이 여타 조건문이나 반복문과 똑같다.
-> parameter 주는 것 등은 C++과 같다. 당연히 매개변수의 개수만큼만 pass해야 된다. 그러나 이때 '가변 매개변수'라는 개념이 등장한다.

● 매개변수 시리즈(가변, 기본, 일반 그리고 키워드 매개변수)

1) '가변 매개변수 함수 variadic arguments function'는 가변 매개변수를 허용하는 함수인데, 매개변수의 개수를 특정하지 않고 동적으로 할당하는 녀석을 일컫는다.
예를 들어 print()함수가 있다.

def print(n, *values)               <- 여기에 print(3, "안녕하세요", "즐거운", "파이썬 프로그래밍") 이렇게 pass 할 수 있다.
    for i in range(n):              
        for value in values:        <- value in values 이렇게 진행되는데 values가 마치 배열처럼 인지되는 것이다.
            print(value)
        print()
가변 매개변수의 제약 조건: 가변 매개변수 뒤에는 일반이든 가변이든 매개변수가 올 수 없다. 즉, 한 함수에 가변 매개변수는 하나만 사용할 수 있다.

2) '기본 매개변수 default parameter'는 변수 정의 및 배정을 하는 녀석이고 꼴은 apple = "delicious" 통째로 매개변수 자리에 들어감. 기본 매개변수의 뒤에는 일반 매개변수가 올 수 없다.

1), 2) 가변과 기본은 서로를 침해한다. 기본이 먼저 오냐, 가변이 먼저 오냐에 따라 자료형 케이스 별로 결과값에 차이는 있지만, 원하는 결과가 안 나올 가능성이 높다.
이 두 가지를 모두 사용하고 싶을 땐? 키워드 매개변수가 답이다.

3)  키워드 매개변수

함수를 호출할 때, 키워드를 지정하며 부르는 것이다. 나중에 활용하게 되면 그때 디테일은 다시 보자.

def value_times(plus, value, times=2): 
	print(times * value + plus) 

value_times(1, 2)                       # 위치 매개변수 순서대로 넘겨줌 times는 2가 됨
value_times(1, 2, 3)                    # 위치 매개변수 순서대로 넘겨줌 times는 3이 됨
value_times(1, value=2, times=3)        # 위치 매개변수 후에 키워드 인자로 값을 넘겨줌 times는 3이 됨 
value_times(value=2, times=3, plus=1)   # 키워드 인자만 있는 경우 순서는 상관없다.

● 함수의 리턴
C++에서는 함수의 리턴값을 지정해두면 해당 자료형을 리턴해줘야 하는 것에 반해, 파이썬에서는 def 달랑 하나로 함수를 시작하기 때문에 return 값이 아무래도 상관없다. 역시 킹연성!
그냥 return을 해줌으로써 아무것도 리턴하지 않으면 None을 출력한다.

함수에 대해서 이론적으로 공부를 하는 것은 여기까지다. 이 이상은 계속해서 함수를 보고 이해하고 더 좋은 코드를 짜보는 수밖에 없다.

● 함수의 활용
재귀함수 Recursion
잘못 사용하면 같은 것을 기하급수적으로 많이 반복. 그러나 잘만 사용하면 코드의 가독성을 높이고 직관적인 코드가 가능함. memoization을 해주지 않으면 엉망이다.
※ 프로그램이 너무 길어진다 싶으면 global 키워드 써서 확인 가능. ex) global counter

● 함수의 고급
※ 머신러닝 프로젝트를 진행하면서 가장 빈번하게 질문 받은 항목이 tuple, lambda, 파일 처리 라고 한다.

1. tuple: 리스트와 비슷한 자료형. 앞에서도 언급됐듯 한 번 결정된 요소를 바꿀 수 없다. 꼴은 (data, data, data, ...). 튜플은 빠르기 때문에 쓰는 거지 리스트에 비하면 사실 형편없다.
          만약 하나만 저장하고 싶다면 (one) 이러면 안 되고 (one,) 이렇게 해줘야 한다.
          괄호가 없는 꼴도 가능한데, tuple_test = 1, 2, 3, 4 이렇게 정의하면 이게 곧 튜플이다. - dict는 {}, list는 [], set은 {something} 혹은 set().
	  (a, b) = (c, d) 이런 식으로 배정 가능하니 괄호가 없는 a, b = c, d가 가능하다. 		★ 신기한 것은, a,b = b,a도 인정되어 이것이 swap() 기능을 한다는 것이다.
	  괄호가 없는 채로 ,만을 사이에 두고 사용되는 경우가 허다하니, 헛갈릴 수 있다는 것을 인지하자.

★ 2. lambda: 함수를 매개변수로 전달하는 코드. 매개변수를 함수로 전달하기 위해 함수 구문을 번거롭게 작성하고 코드를 낭비하는 것이 아까워 만들어진 lambda. 즉 간단한 함수를 쉽게 선언하는 법.
      	      lambda 매개변수: 리턴값 의 꼴을 가지고 있다.

3. 파일 처리: 파일은 크게 텍스트 파일과 바이너리 파일로 나뉘는데, 텍스트 파일을 주 타겟으로 하자.
		1) 파일 열기: 파일을 열 때는 파일 객체 = open(문자열: 파일 경로, 문자열: 읽기 모드) 함수를 사용.
		              모드는 총 세 가지 - 새로 쓰기 모드 w, 뒤에 이어서 쓰기 모드 a, 읽기 모드 r.
		2) 파일 닫기: 파일 객체.close()
		open을 해줬으면 close를 해줘야 하는데 사이에 줄이 길어지면 까먹을 수 있다. 그때 까먹지 않게 하기 위해 
			with open(문자열: 파일 경로, 문자열: 모드) as 파일 객체
		    	문장
        	파일을 읽고 싶을 때는 위의 모드를 r로 해준 다음에 contents = file.read() 해주면 된다. 모드를 r로 해준다고만 해서 읽는 게 아니라, 말 그대로 읽을 준비를 하는 거다.
		3) 텍스트 한 줄씩 읽기: CSV, XML, JSON 등이 있다. 이 중 CSV는 한 줄에 하나의 데이터를 나타내며, 쉼표를 사용해 데이터를 구분.
				 (name, weight, height) = line.strip().split(",") 을 사용해주면 됨.

		 plus) 제너레이터: 함수 내부에 yield 키워드를 사용하면 해당 함수는 제너레이터 함수가 되며, 함수를 호출해도 함수 내부의 코드가 실행되지 않는다.
		 				  제너레이터는 이터레이터를 직접 만들 때 사용하는 코드. 일단은 여기까지만 알아두고 디테일은 실무에서.


















