<k번째 수>, <평균 구하기>, <예산>, <핸드폰 번호 가리기>, <x만큼 간격이 있는 n개의 숫자>, <약수의 합>, <내적>, <자릿수 더하기>, <문자열 다루기 기본>, <콜라츠 추측>, <짝수와 홀수>, 
<같은 숫자는 싫어>, <서울에서 김서방 찾기>, <자연수 뒤집어 배열로 만들기>, <수박수박수박수박수?>, <직사각형 별찍기>
easy. nothing to comment.

<시저 암호>
isupper() 함수와 islower() 함수 활용해주기.
C++ 에서는 ASCII code로 따로 변환해주지 않아도 알아서 컴파일러가 변환 즉, char - 1 같은 것들이 가능하지만, python에서는 형 변환을 해 줘야 함.
char를 ASCII로 변환할 때에는 ord()를, ASCII를 char로 변환할 때에는 chr()를 사용해주면 된다.

<나누어 떨어지는 숫자 배열>
sorted(answer)과 answer.sort()의 각각의 활용을 잘 고려해서 하도록.

<문자열 내 p와 y의 개수>
s.lower().count('p')를 쓰면 엄청나게 단축됨.

<두 개 뽑아서 더하기>
기본적으로 파이썬에서 인덱싱 신경써주자.

<2016년>
리스트 두 개를 사용하여 sum 함수를 활용해주면 더할 나위 없다. sum(months[:a-1]) 뭐 이런 식으로 sum function에도 슬라이싱이 가능하다는 것도 유념.

<이상한 문자 만들기>
(조건1 실행문) if 조건1 else (else 실행문)          <- 이 템플릿 온전히 활용하자! 코드 길이 줄이는 데에 유용하게 쓰일 듯.

<두 정수 사이의 합>
sum의 슬라이싱이 가능하다고 했는데, 자세히 보니 sum은 슬라이싱이 따로 없고 사실 리스트를 슬라이싱한 녀석을 sum의 매개변수를 사용해주는 것이다.

<가운데 글자 가져오기>
쉬운 문제인데, 홀수와 짝수를 각각 2로 나누었을 때 적절한 결과를 낼 수 있는 보편적인 코드를 생각하면 더욱 좋다. 바로바로 str[(len(str)-1)//2:len(str)//2+1]

<문자열 내림차순으로 배치하기>
sorted(s) 를 사용하면 문자열인 s도 sort 가능하다. 그리고 join 함수 발견!

<정수 제곱근 판별>
math라는 모듈 안의 sqrt 함수를 사용하고 싶다면
1. import math 해주고 sqrt 할 때마다 math.sqrt 해줘도 되고 매번 써주기 귀찮으면
2. from math import sqrt 해주면 이제 sqrt에 한해서는 더 이상 math 떡칠 안 해줘도 됨.

<3진법 뒤집기> 분명 쉽게 돼야하는데... 일단 보류!

<문자열 내 마음대로 정렬하기>
놀라 나자빠질만한 답이다. 나는 처음에 자릿수 char끼리 비교해서 큰 틀에서 정렬해주고 이후에 부분적 정렬을 시도했다.
물론 이 풀이도 나쁘지 않은 풀이지만, C++ STL을 활용할 수 있는 정말 좋은 풀이가 하나 더 있다.
#include <algorithm> 내에 있는 sort 함수를 쓸 때 일반적으로 그냥 v.begin() v.end() 써 주곤 했는데, 뒤에 인자를 하나 더 붙이면
reverse나 부분 비교와 같은 기능을 추가할 수 있다. 그러니까 이 문제의 경우에는, sort(strings.begin(), strings.end(), cmp)자릿수의 비교를 먼저 해주는 기능을 추가할 수 있었다.
* 참고: sort의 iterator는 [,)다. 즉, sort 해주고 싶은 마지막 성분보다 하나 크게 범위를 잡아야 한다는 것이다.

<제일 작은 수 제거하기>
역시 리스트에 있어서는 파이썬은 최강의 언어다. 위의 대부분의 문제들을 C++과 비교해서 말도 안 되게 짧은 길이에 풀 수 있었는데 이 문제에서도 마찬가지다.
리스트 arr에서 가장 작은 놈을 찾아낼 때 min(arr)를 써주면 그만이다.

<최대공약수와 최소공배수>
이번 기회에 최대공약수, 최소공배수, 그리고 이 둘과 곱 등의 복합적인 문제에 대한 해결법을 완전히 숙지하자.
최대공약수(Greatest Common Divisor):
    Euclidean Algorithm이라는 멋진 계산법이 있다.
    1. 최대공약수를 구하는 함수를 gcd(x,y)라고 가정.
    2. x%y != 0 이라면 gcd(x, y) = gcd(x, x%y), 이걸 반복
    3. x%y == 0 이면 y가 곧 gcd(x,y) 임.
이 유클리드 호제법만 알면 gcd를 재귀로 쉽게 구할 수 있고, gcd를 알면 gcm을 알 수 있으니 이건... 길이, 쓰임새, 범용성, 최고의 호제법! whoo!

<행렬의 덧셈>
pseudocode로 지 맘대로 []을 두 개 싸놓고 그게 2D라고 주장하는 것 같더라니 역시 틀렸다. 2D든 뭐든 리스트라면 그냥 []로 써준다.

<하샤드 수>
세 줄 컷! Legendary!

<문자열을 정수로 바꾸기>
cast 활용. 한 줄 컷.

<정수 내림차순으로 배치하기>
for c in str(n): v.append(c) 해줄 필요없이 걍 list(str(n)) 해주면 됨!

<소수 만들기>
1. 예를 들어 몇 개 중 서로 겹치지 않는 중 몇 개를 뽑는데 나올 수 있는 조합들을? 한다면 바로~ combinations을 써주면 됨.
만약 순서가 중요하다면 permutations을 써주면 되고. 두 개 다 itertools 라는 모듈에 위치하므로 import 해줘야 함.
2. 소수를 만들 때는 에라토스테네스의 체를 쓴다. 나중에 디테일에 주목하자.

<신규 아이디 추천>
첫 인상은 길이는 길지만 상당히 쉬운 문제라고 생각됐는데 C++과 Python 두 언어에서 모두 syntax 에러를 극복하지 못했다.
python 문법을 활용하는 좋은 예시들이 상당히 많다. 외우고 체화하자.

    new_id = new_id.lower()
    for c in new_id:
        if c.isalpha() or c.isdigit() or c in ['-', '_', '.']: answer += c
    while '..' in answer: answer = answer.replace('..', '.')
    while len(answer) < 3:
        answer += answer[-1]
    return answer
    
<소수 찾기>

<실패율>

<체육복>

<폰켓몬>

<완주하지 못한 선수>

<문자열 내 마음대로 정렬하기>

<크레인 인형뽑기 게임>

<모의고사>
