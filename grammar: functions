21.03.24.   [p210 ~ p269]-----------------------------------------------------------------------------------------------------------------------------------------------------------
Chapter 05. FUNCTION

● 함수의 기본
def 함수 이름():
    문장
-> 꼴이 여타 조건문이나 반복문과 똑같다.
-> parameter 주는 것 등은 C++과 같다. 당연히 매개변수의 개수만큼만 pass해야 된다. 그러나 이때 '가변 매개변수'라는 개념이 등장한다.

● 매개변수 시리즈(가변, 기본, 일반 그리고 키워드 매개변수)

1) '가변 매개변수 함수 variadic arguments function'는 가변 매개변수를 허용하는 함수인데, 매개변수의 개수를 특정하지 않고 동적으로 할당하는 녀석을 일컫는다.
예를 들어 print()함수가 있다.

def print(n, *values)               <- 여기에 print(3, "안녕하세요", "즐거운", "파이썬 프로그래밍") 이렇게 pass 할 수 있다.
    for i in range(n):              
        for value in values:        <- value in values 이렇게 진행되는데 values가 마치 배열처럼 인지되는 것이다.
            print(value)
        print()
가변 매개변수의 제약 조건: 가변 매개변수 뒤에는 일반이든 가변이든 매개변수가 올 수 없다. 즉, 한 함수에 가변 매개변수는 하나만 사용할 수 있다.

2) '기본 매개변수 default parameter'는 변수 정의 및 배정을 하는 녀석이고 꼴은 apple = "delicious" 통째로 매개변수 자리에 들어감. 기본 매개변수의 뒤에는 일반 매개변수가 올 수 없다.

1), 2) 가변과 기본은 서로를 침해한다. 기본이 먼저 오냐, 가변이 먼저 오냐에 따라 자료형 케이스 별로 결과값에 차이는 있지만, 원하는 결과가 안 나올 가능성이 높다.
이 두 가지를 모두 사용하고 싶을 땐? 키워드 매개변수가 답이다.

3)  키워드 매개변수

함수를 호출할 때, 키워드를 지정하며 부르는 것이다. 나중에 활용하게 되면 그때 디테일은 다시 보자.

def value_times(plus, value, times=2): 
	print(times * value + plus) 

value_times(1, 2)                       # 위치 매개변수 순서대로 넘겨줌 times는 2가 됨
value_times(1, 2, 3)                    # 위치 매개변수 순서대로 넘겨줌 times는 3이 됨
value_times(1, value=2, times=3)        # 위치 매개변수 후에 키워드 인자로 값을 넘겨줌 times는 3이 됨 
value_times(value=2, times=3, plus=1)   # 키워드 인자만 있는 경우 순서는 상관없다.

● 함수의 리턴
C++에서는 함수의 리턴값을 지정해두면 해당 자료형을 리턴해줘야 하는 것에 반해, 파이썬에서는 def 달랑 하나로 함수를 시작하기 때문에 return 값이 아무래도 상관없다. 역시 킹연성!
그냥 return을 해줌으로써 아무것도 리턴하지 않으면 None을 출력한다.

함수에 대해서 이론적으로 공부를 하는 것은 여기까지다. 이 이상은 계속해서 함수를 보고 이해하고 더 좋은 코드를 짜보는 수밖에 없다.

● 함수의 활용
재귀함수 Recursion
잘못 사용하면 같은 것을 기하급수적으로 많이 반복. 그러나 잘만 사용하면 코드의 가독성을 높이고 직관적인 코드가 가능함. memoization을 해주지 않으면 엉망이다.
※ 프로그램이 너무 길어진다 싶으면 global 키워드 써서 확인 가능. ex) global counter

● 함수의 고급
※ 머신러닝 프로젝트를 진행하면서 가장 빈번하게 질문 받은 항목이 tuple, lambda, 파일 처리 라고 한다.

1. tuple: 리스트와 비슷한 자료형. 앞에서도 언급됐듯 한 번 결정된 요소를 바꿀 수 없다. 꼴은 (data, data, data, ...). 튜플은 빠르기 때문에 쓰는 거지 리스트에 비하면 사실 형편없다.
          만약 하나만 저장하고 싶다면 (one) 이러면 안 되고 (one,) 이렇게 해줘야 한다.
          괄호가 없는 꼴도 가능한데, tuple_test = 1, 2, 3, 4 이렇게 정의하면 이게 곧 튜플이다. - dict는 {}, list는 [], set은 {something} 혹은 set().
	  (a, b) = (c, d) 이런 식으로 배정 가능하니 괄호가 없는 a, b = c, d가 가능하다. 		★ 신기한 것은, a,b = b,a도 인정되어 이것이 swap() 기능을 한다는 것이다.
	  괄호가 없는 채로 ,만을 사이에 두고 사용되는 경우가 허다하니, 헛갈릴 수 있다는 것을 인지하자.

★ 2. lambda: 함수를 매개변수로 전달하는 코드. 매개변수를 함수로 전달하기 위해 함수 구문을 번거롭게 작성하고 코드를 낭비하는 것이 아까워 만들어진 lambda. 즉 간단한 함수를 쉽게 선언하는 법.
      	      lambda 매개변수: 리턴값 의 꼴을 가지고 있다.

3. 파일 처리: 파일은 크게 텍스트 파일과 바이너리 파일로 나뉘는데, 텍스트 파일을 주 타겟으로 하자.
		1) 파일 열기: 파일을 열 때는 파일 객체 = open(문자열: 파일 경로, 문자열: 읽기 모드) 함수를 사용.
		              모드는 총 세 가지 - 새로 쓰기 모드 w, 뒤에 이어서 쓰기 모드 a, 읽기 모드 r.
		2) 파일 닫기: 파일 객체.close()
		open을 해줬으면 close를 해줘야 하는데 사이에 줄이 길어지면 까먹을 수 있다. 그때 까먹지 않게 하기 위해 
			with open(문자열: 파일 경로, 문자열: 모드) as 파일 객체
		    	문장
        	파일을 읽고 싶을 때는 위의 모드를 r로 해준 다음에 contents = file.read() 해주면 된다. 모드를 r로 해준다고만 해서 읽는 게 아니라, 말 그대로 읽을 준비를 하는 거다.
		3) 텍스트 한 줄씩 읽기: CSV, XML, JSON 등이 있다. 이 중 CSV는 한 줄에 하나의 데이터를 나타내며, 쉼표를 사용해 데이터를 구분.
				 (name, weight, height) = line.strip().split(",") 을 사용해주면 됨.

		 plus) 제너레이터: 함수 내부에 yield 키워드를 사용하면 해당 함수는 제너레이터 함수가 되며, 함수를 호출해도 함수 내부의 코드가 실행되지 않는다.
		 				  제너레이터는 이터레이터를 직접 만들 때 사용하는 코드. 일단은 여기까지만 알아두고 디테일은 실무에서.

<챕터 5 끝>
